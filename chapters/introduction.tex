% Here the topic should be introduced, and the structure, goal and scope of the thesis should be defined.
% One should focus on answering the following question: Why is the topic of the Thesis interesting for the (scientific) community?
\chapter{Introduction}
\label{chap:introduction}

\begin{comment}
Rust as new language competitive to C?
Bare-metal still necessary with modern Microprocessors and Real-time Linux?
What if we want to implement something different from linear control?
\end{comment}

\section{Closed Loop Control}
\label{sec:introduction:clc}

Whenever you have a stateful system there are two ways of controlling it.
In Open Loop Control only the should-be signal influences the output value.
In Closed Loop or Feedback Control the output is composed of the should-be value and a feedback signal that measures the actual state of the system.
In many real-world applications Closed Loop Control is used for its ability to quickly reach a new target value, while keeping oscillation and overshoot to a minimum.

For these real-world applications it has been implemented in many different ways,
from mechanical structures like a centrifugal governor to specialized integrated circuits.

In this paper we will implement closed loop control of a brushless DC motor on a Raspberry Pi 4.
This effort is part of the larger goal of building a successor to CARL\cite{CARL} at RRLAB.
There are a variety of different ways the motor controllers could be implemented, the old CARL for example used FPGAs.
We chose to use a Raspberry Pi, because it provides us with some advantages and exciting opportunities.

\section{Advantages of Closed Loop Control on General Purpose Processors}
\label{sec:introduction:gpp}

When compared to the FPGA approach used in CARL Single Board Computers (from now on abbreviated as SBCs) such as a Raspberry Pi are cheaper and easier to program.
This comes at a cost however, typically FPGAs are faster at high speed IO operations, which is an important port of a Closed Loop Controller.
Fortunately the Raspberry Pi 4 has special purpose hardware for SPI and PWM IO which should help us alleviate this disadvantage,
while outperforming the FPGAs in general compute tasks due to the higher clock frequencies.

When compared to ready built PID ICs a Raspberry Pi is more expensive, consumes more power and must be programmed vs only settings a few variables.
But it comes with one major upside for a research project such as ours:
It is not bound to a traditional PID controller. If the need arises to use a different control scheme or compute additional tasks in parallel, the Raspberry Pi can!

In addition, using a Raspberry Pi provides an opportunity to use the Rust programming language and validate some of its claims.

\section{A new programming language for embedded systems?}
\label{sec:introduction:rust}

Systems programming and embedded systems are two closely linked categories.
In both of them the usage of C++ and especially C have dominated that of any other language.
In the last 5-10 years however several new languages have come up,
that claim to be able to replace C and C++ for various parts of the systems programming field.
\begin{itemize}
    \item Go by Google has seen wide adoption in high-performance network related applications, due to its focus on simplicity while maintaining reasonably high performance.\cite{Go}
    \item Zig targets a direct replacement of C for low level systems such as writing operating system kernels or embedded applications. In order to easily integrate into existing C projects the zig compiler can compile both C and Zig files.\cite{Zig}
    \item Carbon directly targets replacing C++ by being able to include C++ files and compiling to the same ABI.\cite{Carbon}
    \item Rust, which was originally developed by Graydon Hoare at Mozilla.\cite{TheRustProgrammingLanguage}
\end{itemize}

The controller implementation in this thesis will be written in Rust,
as that gives us the opportunity to validate some of Rusts claims on its suitability for embedded programs and interoperability with existing SDKs.

To cite the exact quotes we will be looking at in detail:\\
"Interoperability - Integrate Rust into your existing C codebase or leverage an existing SDK to write a Rust application."\\
"Portability - Write a library or driver once, and use it with a variety of systems, ranging from very small microcontrollers to powerful SBCs."\\
\cite{RustEmbeddedSite}

In order to do that we will implement the controller twice.
Once running bare-metal while using the Circle library for interacting with the hardware,
and second while running on a standard linux kernel on the Raspberry Pi.
This allows us to compare the effort of writing an embedded application in Rust to the effort
when writing the same application on top of a general purpose operating system.
The Circle library is a C/C++ SDK for all Raspberry Pis which will serve as our test bed for exploring Rust's C interoperability.

Since we will be taking a detailed look at some of Rusts features let us provide some general information on the language.

Rust was designed to be a similarly performant alternative to C and C++ while eliminating some of their most common pitfalls:\\
\begin{itemize}
    \item buffer overflows
    \item out of bounds read
    \item race conditions
    \item reading uninitialized memory
    \item dereferencing null pointers
\end{itemize}

It does this through a combination of approaches where the most important ones are RAII through an ownership system and a lifetimes for references instead of pointers.
We will cover these in more detail in the background (\ref{background}) chapter.