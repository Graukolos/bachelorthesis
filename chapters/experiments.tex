% This is the second main part of the thesis. The experiments should be suitable to validate your approach.
% Define the experimental setting, e.g. the robot or the dataset, the metrics as well as the results.
% The visualization of the results should be in a way such that it is easily understandable.
% Usually, first, the results are reported and then the effects of the results on the defined problem are discussed.
% Answer the question, what parts of the problem did you solve?
\chapter{Experiments}
\label{chap:experiments}

In order to compare our different approaches we measured the time an iteration of our control loop takes.
This allows us to compare not only the speed of each program version but also the consistency in the iteration times.

\section{Methodology}
\label{sec:experiments:methodology}

In order to make the benchmarks as comparable as possible we set a few invariants between the runs:
\begin{itemize}
    \item Each of the benchmarks is run on the exact same RaspberryPi 4B.
    \item The Pi runs at the stock core frequency of 1800MHz.
    \item The linux versions run RaspberryPi OS, a derivative of Debian Linux with the stock configuration.
    \item The kernel version is 6.1.73 for the stock and isolated core versions.
    \item The realtime version runs on 6.1.73-rt which was compiled prior on the RaspberryPi. For Instructions to replicate this kernel see the Appendix \ref{sec:appendix:realtime}.
    \item Our control loop target value is set to a constant for these tests and the IC-MU position encoder is fixed in place in order to return almost the same value each iteration.
    //TODO compiler version
\end{itemize}

\subsection{Testing the linux based versions}
The linux versions all run a common iteration function:
\begin{lstlisting}[language=Rust,style=colouredRust]
    pub fn iteration(...) -> Instant {
        // fetch step: calculate elapsed time, get new position and setpoint
        let iteration_time = last_iteration_start.elapsed();
        let iteration_start = Instant::now();
    
        let position = get_position(spi);
        let setpoint = get_setpoint();
    
        // compute step: calculate new output value
        pid.setpoint = setpoint;
        let output = pid
            .step(pid_ctrl::PidIn::new(position, iteration_time.as_secs_f64()))
            .out;
    
        // update step: output the new value over PWM
        pwm.set_duty_cycle(output).unwrap();
    
        iteration_start
    }
\end{lstlisting}

Time measurment is done here through Rusts stdlib Instant and Duration types.
On linux these compile to the clock\_gettime syscall in order to get microsecond accurate time.
Because the RaspberryPi 4 does not yet have a real time clock like the Raspberry Pi 5 linux uses the clock interrupts to measure the time.
To execute the benchmarks the criterion framework for Rust was used as it allows easy configuration of the amount of samples,
runs an unmeasured three second warmup loop of the benchmark beforehand and automatically generates plots and statistics data from the results.

For the isolated core version we use the cset python program in order to easily manipulate the linux kernels cpuset subsystem.
This allows us with few commands to isolate one core from all running processess and run our program on it, without being disturbed by core local interrupts.
Global interrupts such as spinlocks when running a syscall can however still halt our execution flow.

We can run cset from inside of our program with the current process id this way:
\begin{lstlisting}[language=Rust,style=colouredRust]
    Command::new("sudo")
        .args([
            "cset",
            "shield",
            "--cpu=3",
            "--kthread=on",
            &format!("--pid={}", std::process::id()),
        ])
        .spawn()
        .expect("Could not start cset binary")
        .wait()
        .expect("cset did not exit successfully");
\end{lstlisting}

For the realtime version we needed a kernel that can boot with the Raspberry Pi bootloader,
have the out-of-tree kernel modules for spi and pwm and support fully preemtive scheduling.
In order to get that combination, the official sources for the Rpi kernel were patched with the fitting version of the PREEMP\_RT patchset and compiled.

To achieve this Step 1 is to get all the required build dependencies.
\begin{lstlisting}[language=bash, breaklines]
    sudo apt update && sudo apt install build-essential flex bison libssl-dev bc
\end{lstlisting}

Step 2 is to get the kernel sources and patch them with the correct PREEMPT-RT patchset.
\begin{lstlisting}[language=bash, breaklines]
    wget https://github.com/raspberrypi/linux/archive/refs/tags/stable_20240124.tar.gz
    wget https://cdn.kernel.org/pub/linux/kernel/projects/rt/6.1/older/patch-6.1.73-rt22.patch.xz
    tar -xf stable_20240124.tar.gz
    cd linux-stable_20240124
    xzcat ../patch-6.1.73-rt22.patch.xz | patch -p1
\end{lstlisting}

Step 3 is to generate the kernel config, we use the provided default config for the Raspberry Pi 4 and only set the PREEMPT\_RT config value to enable full kernel preemption.
\begin{lstlisting}[language=bash, breaklines]
    make bcm2711_defconfig
    ./scripts/config -e PREEMPT_RT
    make olddefconfig
\end{lstlisting}

Step 4 is to actually compile the kernel, this takes about 3 hours on all 4 cores of the Raspberry Pi 4.
\begin{lstlisting}[language=bash, breaklines]
    make -j4 Image.gz modules dtbs
\end{lstlisting}

Step 5 is to actually install the files.
\begin{lstlisting}[language=bash, breaklines]
    sudo make modules_install
    sudo cp arch/arm64/boot/dts/broadcom/*.dtb /boot/firmware/
    sudo cp arch/arm64/boot/dts/overlays/*.dtb* /boot/firmware/overlays/
    sudo cp arch/arm64/boot/dts/overlays/README /boot/firmware/overlays/
    sudo cp arch/arm64/boot/Image.gz /boot/firmware/kernel8.img
\end{lstlisting}

At the end simply reboot to load the new kernel.

\subsection{Testing the bare-metal version}
Benchmarking the bare-metal version is a bit more involved than the linux based versions.
For measuring times Circle's CTimer::GetClockTicks64() is used. This in turn returns the amount of ticks of a 1MHz oscillator on the Rpi.
Similar to criterion in the linux based versions we let the loop run for some period before measuring
in order to avoid any latency spikes because things are not yet copied to the caches.
We set this to 10000 iterations, which as we will later see in the results translates to roughly 3-4 seconds of warmup.

The second difficulty with the bare-metal version is getting the results out of the RaspberryPi.
We need to either transmit the data over a connection such as ethernet, spi, i2c to another PC or save it to a filesystem on removable storage.
Since we are running bare-metal that means we need a driver for one of these options.
Because we are already using the Circle library for Spi and it provides simple access to a USB mass storage device with a FAT32 file system we will be using it to save the results.

The process for this is equivalent to how we already used the SPI and PWM drivers in the \nameref{chap:concept_and_implementation} chapter,
so we will only skim over the most important parts.

In our wrapper.hpp we need to include "circle/fs/fat/fatfs.h" and "circle/usb/usbhcidevice.h"
\begin{lstlisting}[language=C++]
    #include "circle/fs/fat/fatfs.h"
    #include "circle/usb/usbhcidevice.h"
\end{lstlisting}

In our main.rs we initialize these devices and save the measured times as a csv file.
\begin{lstlisting}
    let mut usb_hci =
        ffi::CXHCIDevice::new(&mut interrupt_system, &mut timer, false, 0, null_mut());
    let mut filesystem = ffi::CFATFileSystem::new();


    ((*usb_hci._base._base.vtable_).CUSBController_Initialize)(&mut usb_hci._base._base, true);

    for _ in 0..10000 {
        ...
    }
    const N: usize = 200;
    let mut times = [0; N];
    for time in times.iter_mut() {
        ...
        *time = ffi::CTimer::GetClockTicks64() - iteration_start;
        ...
        iteration_start = ffi::CTimer::GetClockTicks64();
        ...
    }

    let partition = device_name_service.GetDevice(c"umsd1-1".as_ptr(), true);
    filesystem.Mount(partition);

    let file = filesystem.FileCreate(c"times.csv".as_ptr());
    let mut buffer = String::from("iteration,elapsed_time_us\n");
    for (n, time) in times.iter().enumerate() {
        buffer.push_str(&format!("{},{}\n", n, time));
    }
    let buffer = alloc::ffi::CString::new(buffer).unwrap();

    filesystem.FileWrite(
        file,
        buffer.as_ptr() as *const c_void,
        buffer.count_bytes() as u32,
    );
    filesystem.FileClose(file);
    filesystem.UnMount();
\end{lstlisting}

\section{Results}
\label{sec:experiments:results}

% first table with average, std dev, min, max
\begin{table}
    \label{tab:measurments}
\end{table}

% second distribution graphs

% third profiling?

\section{Interpretation}

\begin{comment}
Measure iteration time over x iterations.
Derive average, minimal and maximal iteration times.
Look at variance 
\end{comment}
